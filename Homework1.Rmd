---
title: "Homework1"
output:
  word_document: default
  pdf_document:
    keep_tex: yes
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# FE621.  Assignment #1.

# Problem 1

## Question (a) calculate the price of a call and a put 
```{r}
# Function to calculate opntion price by BS formular
BS <- function(type, S0, K, tau, r, sigma){

  d1 <- (log(S0/K)+(r+sigma^2/2)*tau) / (sigma*sqrt(tau)) 
  d2 <- d1 - sigma*sqrt(tau) 
  if(type=="C"){
    Price <- S0*pnorm(d1) - K*exp(-r*tau)*pnorm(d2)
  }
  if(type=="P"){
    Price <- K*exp(-r*tau)*pnorm(-d2) - S0*pnorm(-d1)
  }
  return(Price)
}
#input the value that problem give
s0 <- 100
K <- 100
tau <- 30/252
r <- 0.05
sigma <- 0.20

C <- BS("C", s0, K, tau, r, sigma)
P <- BS("P", s0, K, tau, r, sigma)
C  #call option price
P  #put option price
```

##Question(b) Check put-call parity
```{r}
s0 - K * exp(-r*tau)
C - P
```
\textcolor{blue}{conclusion:} we can see that S0 - K * exp(-r*tau)=0.5934701, which equals to call  option price - put option price, so we can say that Put-Call parity relation holds.

##Question(c) use bisection method to calculate Implied volatility
```{r}
getwd() # get currency work directory
#read data that download from Yahoo finance
JPM1 <- read.csv("JPM CallsForFebruary 17, 2017.csv")
JPM2 <- read.csv("JPM CallsForMarch 17, 2017.csv")
JPM6 <- read.csv("JPM CallsForJuly 21, 2017.csv")
#calculate market price
MPrice1 <- matrix((JPM1$Bid + JPM1$Ask)/2) #one month
MPrice2 <- matrix((JPM2$Bid + JPM2$Ask)/2) #two month
MPrice6 <- matrix((JPM6$Bid + JPM6$Ask)/2) #six month

S0 <- 83.55 # Close price of JPM at 2017-01-17
#strike price of JPM option
K1 <- matrix(JPM1$Strike) #one month
K2 <- matrix(JPM2$Strike) #two month
K6 <- matrix(JPM6$Strike) #six month
#calculate time t of each option
tau1 <- as.numeric(difftime("2017-02-17","2017-01-17",units = "days"))/252
tau2 <- as.numeric(difftime("2017-03-17","2017-01-17",units = "days"))/252
tau6 <- as.numeric(difftime("2017-07-21","2017-01-17",units = "days"))/252

err <- function(S0,K,r,tau,sig,MPrice){
   BS("C",S0,K,r,tau,sig) - MPrice
}

#Function to find BS Implied Vol using Bisection Method
Ivol <- function(S0, K, tau, r, MPrice){ 
  sig <- c()
#loop for every strike price and market price
  for(i in 1:20){
    a <- 0
    b <- 1
    c <- (a+b)/2
    fa <- err(S0,K[i],r,tau,a,MPrice[i])
    fc <- err(S0,K[i],r,tau,c,MPrice[i])
#Loop until that the value of function to sigma is less than tolerance level 1e-4 
    while(abs(b-a) > 1e-4){
      
      if( fa * fc < 0)
          b <- c
      else 
          a <- c
      # print(a)
      # print(b)
    c <- (a+b)/2
   # print(c)
    fa <- err(S0,K[i],r,tau,a,MPrice[i])
    fc <- err(S0,K[i],r,tau,c,MPrice[i])
    }
   sig <- c(sig,c)
  }
  return(sig)
}
Imv1 <- Ivol(S0,K1,0.05,tau1,MPrice1) #one month
Imv2 <- Ivol(S0,K2,0.05,tau2,MPrice2) #two month
Imv3 <- Ivol(S0,K6,0.05,tau6,MPrice6) #six month
Imv1
#present the result in a table
DF1 <- data.frame(Imv1,Imv2,Imv3)
DF1
```

##Question(d) use secant method to calculate implied volatility
```{r}
# Function to find BS Implied Vol using Secant Method
secant <- function(S0,K,r,tau,MPrice){
  sig <- c()
#loop for every strike price and market price
  for(i in 1:20){
    n = 0
    x0 <- -5
    x1 <- 0
    err0 <- err(S0,K[i],r,tau,x0,MPrice[i])
    err1 <- err(S0,K[i],r,tau,x1,MPrice[i])
#Loop until that the value of function to sigma is less than tolerance level 1e-4 
      while(abs(x1-x0) > 1e-4){
      x <- x1 - err1*(x1 - x0) / (err1 - err0) # Calculate the new x value
      x0 <- x1
      x1 <- x
      n = n+1
    }
  sig <- c(x,sig)
  }
  print(n) #output the step that need to reach convergence
  return(sig)
}
Iv1 <- secant(S0,K1,0.05,tau1,MPrice1) #one month
Iv2 <- secant(S0,K2,0.05,tau2,MPrice2) #two month
Iv3 <- secant(S0,K6,0.05,tau6,MPrice6) #six month
#present the result in a table
DF2 <- data.frame(Iv1,Iv2,Iv3)
DF2
```
\textcolor{blue}{conclusion:} I use two different interval for this two method, because I tried to set interval [0,2]
in the secant method, but only one month option data can get outcomes. I think the reason of that is secant method has highly requirement of the interval you select. Also, I test the number of iterations neccessary to reach convergence, bisection method use 18,19,14 for JPM option of three different maturity, and  secant method use 6,5,2 steps for that.
Therefore, my conclusion is that secant method is faster than bisecation, but the selection of secant method has more limitation than the bisection.

##Question(e) plot implied volatility
```{r}
# two dimensional plot of implied volatilities versus strike
# 2D plot for implied vol that calculate by bisection method
plot(K1, Imv1, typ="b", col="green", main=c("JPM Feb Call", "Volatility Smile"),
     xlab="Strike", ylab="Implied Vol")
lines(K2, Imv2, col="red")
lines(K6, Imv3)
## 2D plot for implied vol that calculate by secant method
plot(K1, Iv1, typ="b", col="green", main=c("JPM Feb Call", "Volatility Smile"),
     xlab="Strike", ylab="Implied Vol")
lines(K2, Iv2, col="red")
lines(K6, Iv3)

# Creat 3D plot of volatilities versus K & T
COLOR=c(rep("red",20),rep("blue",20),rep("green",20))
library(scatterplot3d)
t1 <- rep(tau1,20)
t2 <- rep(tau2,20)
t3 <- rep(tau6,20)
scatterplot3d(c(K1,K2,K6),c(t1,t2,t3),c(Imv1, Imv2, Imv3),main="Bisection 3D plot",
              color = COLOR,pch=16,type = "p")
scatterplot3d(c(K1,K2,K6),c(t1,t2,t3),c(Iv1, Iv2, Iv3),main="Secant 3D plot",
              color = COLOR,pch=16,type = "p")
```


##Question(f) Greeks
```{r}
# method1 use formula to calculate
d1 <- (log(s0/K)+(r+sigma^2/2)*tau) / (sigma*sqrt(tau)) 
d2 <- d1 - sigma*sqrt(tau)
norm_deriv <- 1.0/sqrt(2*pi) * exp(-d1^2/2)

Delta <- pnorm(d1)
Delta

Vega <- norm_deriv * s0 * sqrt(tau) 
Vega

Gamma <- norm_deriv * (1.0/(s0 * sqrt(tau)*sigma))
Gamma

# method2 use approximation
#delta
delta <- function(s0,K,r,T,sigma){
  ybi <- 0.0001
  y <- (BS("C", s0+ybi, K, tau, r, sigma)-BS("C", s0, K, tau, r, sigma))/ybi
  return(y)
}
delta(s0,K,r,tau,sigma)

#vega
vega <- function(s0,K,r,T,sigma){
  ybi <- 0.0001
  y <- (BS("C", s0, K, tau, r, sigma+ybi)-BS("C", s0, K, tau, r, sigma))/ybi
  return(y)
}
vega(s0,K,r,tau,sigma)

#gamma
gamma <- function(s0,K,r,T,sigma){
  ybi <- 0.00001
  y <- (BS("C", s0+2*ybi, K, tau, r, sigma)-2*BS("C", s0+ybi, K, tau, r, sigma)
        + BS("C", s0, K, tau, r, sigma))/ybi^2
  return(y)
}
gamma(s0,K,r,tau,sigma)
```
\textcolor{blue}{conclusion:} By using formula directly, we can get Delta=0.54806, Vega=13.66481,Gamma=0.05739221. By using approximation to partial derivatives, we can get Delta=0.5480629,Vega=13.66483,Gamma=0.05726974. I think approximation method can get more precision outcomes than using formula directly. 

##Question(g) calulate greeks for option that I download
```{r}
#delta
delta <- function(s0,K,r,T,sigma){
  ybi <- 0.0001
  y <- (BS("C", s0+ybi, K, tau, r, sigma)-BS("C", s0, K, tau, r, sigma))/ybi
  return(y)
}
delta(S0,K1,0.0248,tau1,Imv1)

#vega
vega <- function(s0,K,r,T,sigma){
  ybi <- 0.0001
  y <- (BS("C", s0, K, tau, r, sigma+ybi)-BS("C", s0, K, tau, r, sigma))/ybi
  return(y)
}
vega(S0,K2,0.0248,tau2,Imv2)

#gamma
gamma <- function(s0,K,r,T,sigma){
  ybi <- 0.00001
  y <- (BS("C", s0+2*ybi, K, tau, r, sigma)-2*BS("C", s0+ybi, K, tau, r, sigma) + 
        BS("C", s0, K, tau, r, sigma))/ybi^2
  return(y)
}
gamma(S0,K6,0.0248,tau6,Imv3)
```

#Problem 2

##Question(a) compute integral by trapzoidal and the Simpson rules
```{r}
#input the real-value function that problem give
f <- function(x){
  if (x == 0){
    y <- 1
  }
  else{
    y <- sin(x)/x
  }
  return(y)
}

# Trapezoidal rule
trap1 <- function(a,N){
  In <- 0
  h <- (2*a)/N

  for(i in 1:N){
    x <- (-a)+i*h
    x1 <- (-a)+(i-1)*h
    area <- h*(f(x)+f(x1))/2
    In <- area + In
  }
  return(In)
}
trap1(10^4,10^4)


# Simpson rule
simp1 <-  function(a,N){
  In <- 0
  h <- (2*a)/N
  for(i in 1:N){
    x <- (-a)+i*h
    x1 <- (-a)+(i-1)*h
    area <- (x - x1)/6 *(f(x1)+4*f((x + x1)/2)+f(x))
    In <- area + In
  }
  return(In)
}
simp1(10^4,10^4)
```

##Question(b) compute the truncation error
```{r}
trunerr <- function(type,a,N){
  if(type=="trap")
    trap1(a,N)-pi
  else if(type=="simp")
    simp1(a,N)-pi
}
trunerr("trap",1e+4,1e+4) #truncation error in trapezoidal rule
trunerr("simp",1e+4,1e+4) #truncation error in Simpson rule
```
\textcolor{blue}{conclusion:} truncation error that calculate by Simpson rule is kind of larger than that calculate by trapezoidal rule.

##Question(c) use tolerance value to check every iteration and evaluate the number of step until the algorithms reach convergence
```{r}
# check iteration in trapezoidal rule
trap_check <- function(a){
	n <- 4
	h <- (2*a)/n
  tol <- 1e-4  #set tolerance value
	s <- trap1(a, n)
	s.diff <- tol + 1 # ensures to loop at once.
	while (s.diff > tol ) {
		s.old <- s #
		n <- n+1 #calculate the number of step
		h <- (2*a)/n
		s <- trap1(a,n)
		s.diff <- abs(s-s.old)
	}
	return(n)
}
trap_check(10^4)

# check iteration in Simpson rule
simp_check <- function(a){
	n <- 4
	h <- (2*a)/n
  tol <- 1e-4 #set tolerance value
	s <- simp1(a, n)
	s.diff <- tol + 1 # ensures to loop at once.
	while (s.diff > tol ) {
		s.old <- s
		n <- n+1 #calculate the number of step
		h <- h/2
		s <- simp1(a,n)
		s.diff <- abs(s-s.old)
	}
	return(n)
}
simp_check(10^4)
```
\textcolor{blue}{conclusion:} the number of step until trapezoidal rule get convergence is 3262, and the steps of Simpson rule get convergence is 3229, so that Simpson rule convergence faster than trapezoidal rule.

##Question(d) use trapezoidal and simpson to approximation function that problem give
```{r}
#input the function
g <- function(x){
  y <- 1 + exp(-x) * sin(8*x^(2/3))
  return(y)
}
#quadrature method to approximate
Quadrature <- function(type,N){
  In <- 0
  a <- 0
  b <- 2
  h <- (b-a)/N

  for(i in 1:N){
    x <- (a)+i*h
    x1 <- (a)+(i-1)*h
    if(type == "trap")
      area <- h*(g(x)+g(x1))/2
    else if(type == "simp")
      area <- (x - x1)/6 *(g(x1)+4*g((x + x1)/2)+g(x))
    In <- area + In
  }
  return(In)
}
Quadrature("trap",10^4)
Quadrature("simp",10^4)

# Integral
Integral <- function(type){
  n <- 1
  a <- 0
  b <- 2
  tol <- 1e-4
  
  s <- Quadrature(type, n)
  s.diff <- tol + 1 # ensures to loop at once.
  while (s.diff > tol ) {
    s.old <- s
    n <- n+1
    h <- (b-a)/n
    s <- Quadrature(type,n)
    s.diff <- abs(s-s.old)
  }
  print(n)
  return(s)
}
Integral("trap")
Integral("simp")
```
\textcolor{blue}{conclusion:} convergence steps number in trapezoidal rule is 65, convergence steps number in simpson rule is 27, the out come of integral is around 2.01. Obviously, Simpson rule is more faster than trapezoidal rule.

#Problem 3
```{r}
#input all parameters
r <- 0
q <- 0
rho <- -0.3
theta <- 0.1
sigma <- 0.2
lambda <- 0

i <- sqrt(-1+0i)
kappa <- c(4,2,1)
u1 <- 0.5
u2 <- -0.5
a <- kappa*theta
b1 <- kappa+lambda-rho*sigma
b2 <- kappa+lambda

S <- 1
V0 <- 0.1
T <- 5
k <- c(0.5,0.75,1.0,1.25,1.5)

psi <- function(Phi,b,u){
  d <- sqrt((rho*sigma*Phi*i-b)^2 - sigma^2*(2*u*Phi*i-Phi^2))
  g <- (b-rho*sigma*Phi*i+d)/(b-rho*sigma*Phi*i-d)
  C <- (r-q)*Phi*i*T+kappa*theta*((b-rho*sigma*Phi*i+d)*T - 2*log((1-g*exp(d*T))/(1-g)))/sigma^2
  D <- (b-rho*sigma*Phi*i+d)/sigma^2 * ((1-exp(d*T))/(1-g*exp(d*T)))
  y <- exp( C+D*V0+i*Phi*log(S))
  return(y)
}

expre <- function(Phi,b,u,k){
  y <- Re(exp(-i*Phi*log(k))*psi(Phi,b,u)/(i*Phi))
  return(y)
}

#use simpon method to calculate integral
Simpon <- function(up,N,b,u,k){
 In <- 0
 h <- up/N
 for(j in 1:N+1){
   Phi <- j*h
   Phi1 <- (j-1)*h
   area <- (Phi - Phi1)/6 * (expre(Phi1,b,u,k) + 4*expre((Phi + Phi1)/2,b,u,k)+expre(Phi,b,u,k))
   In <- area + In
 }
 return(In)
}

In1k1 <- mean(Simpon(700,1e+4,b1,u1,k[1]))
In1k2 <- mean(Simpon(700,1e+4,b1,u1,k[2]))
In1k3 <- mean(Simpon(700,1e+4,b1,u1,k[3]))
In1k4 <- mean(Simpon(700,1e+4,b1,u1,k[4]))
In1k5 <- mean(Simpon(700,1e+4,b1,u1,k[5]))
simpon1 <- c(In1k1,In1k2,In1k3,In1k4,In1k5)
In2k1 <- mean(Simpon(700,1e+4,b2,u2,k[1]))
In2k2 <- mean(Simpon(700,1e+4,b2,u2,k[2]))
In2k3 <- mean(Simpon(700,1e+4,b2,u2,k[3]))
In2k4 <- mean(Simpon(700,1e+4,b2,u2,k[4]))
In2k5 <- mean(Simpon(700,1e+4,b2,u2,k[5]))
simpon2 <- c(In2k1,In2k2,In2k3,In2k4,In2k5)

P1 <- 1/2 + 1/pi * simpon1
P2 <- 1/2 + 1/pi * simpon2

#calculate option price by Hedson model
Heston_Price <- S*P1 - k*exp(-(r-q)*T)*P2

DF <- data.frame(k,Heston_Price)
DF
```
\textcolor{blue}{conclusion:} the outcomes I get is close to, but a little lower than the value of Table 1 in paper.
